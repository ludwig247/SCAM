-- MODULE: Sensor
-- SYNC AND NOTIFY SIGNALS (1-cycle macros) --
--macro sensor_sync : boolean := end macro;
--macro value_output_sync : boolean := end macro;
--macro sensor_notify : boolean := end macro;
--macro value_output_notify : boolean := end macro;


-- DP SIGNALS --
macro sensor_sig : numeric := sensor_sig_i end macro;
macro value_output_sig : numeric := value_output_sig_o end macro;


--CONSTRAINTS--
 constraint no_reset := reset = '0'; end constraint;


-- VISIBLE REGISTERS --
--macro value_old : numeric := end macro;
--macro value_output : numeric := value_output_sig_o end macro;
--macro value : numeric := end macro;


-- STATES --
macro idle_R_1 : boolean := sensor_notify = '1' and value_output_notify = '0' end macro;
macro output_W_2 : boolean := sensor_notify = '0' and value_output_notify = '1'end macro;


-- OPERATIONS --


property reset is
  for timepoints:
    t_end = t;
  assume: reset_sequence;
  prove:
    --during[t+1, t_end-1]: sensor_notify = false;
    at t_end: sensor_notify = true;
    --during[t+1, t_end]: value_output_notify = false;

    at t_end: value_old = 0;
    at t_end: idle_R_1;
end property;

property op_1 is
  dependencies: no_reset;
  for timepoints:
    t_end = t+1;
  freeze:
    atT_value_old = value_old @ t;
  assume:
    at t: idle_R_1;
    at t: (not (sensor_sig /= value_old)); --vorher: illegal token: !=
    at t: sensor_sync;
  prove:
    during[t+1, t_end-1]: sensor_notify = false;
    at t_end: sensor_notify = true;
    during[t+1, t_end]: value_output_notify = false;

    at t_end: value_old = atT_value_old;
    at t_end: idle_R_1;
end property;

property wait_2 is
  dependencies: no_reset;
  for timepoints:
    t_end = t+1;
  freeze:
    atT_value_old = value_old @ t;
  assume:
    at t: idle_R_1;
    at t: (not sensor_sync);
  prove:
    at t+1: sensor_notify = true;
    at t+1: value_output_notify = false;

    at t+1: value_old = atT_value_old;
    at t+1: idle_R_1;
end property;

property op_3 is
  dependencies: no_reset;
  for timepoints:
    t_end = t+1;
  freeze:
    atT_sensor_sig = sensor_sig @ t;
  assume:
    at t: idle_R_1;
    at t: (sensor_sig /= value_old); --vorher: illegal token: !=
    at t: sensor_sync;
  prove:
    during[t+1, t_end]: sensor_notify = false;
    during[t+1, t_end-1]: value_output_notify = false;
    at t_end: value_output_notify = true;

    at t_end: value_output = atT_sensor_sig; -- value_output: never used in design
    at t_end: value_old = atT_sensor_sig;
    at t_end: value_output_sig_o = atT_sensor_sig; -- was missing
    at t_end: output_W_2;
end property;

property op_4 is
  dependencies: no_reset;
  for timepoints:
    t_end = t+1;
  freeze:
    atT_value_output = value_output @ t,
    atT_value_old = value_old @ t;
  assume:
    at t: output_W_2;
    at t: value_output_sync;
  prove:
    during[t+1, t_end-1]: sensor_notify = false;
    at t_end: sensor_notify = true;
    during[t+1, t_end]: value_output_notify = false;
    at t: value_output_sig = atT_value_output;

    at t_end: value_old = atT_value_old;
    at t_end: idle_R_1;
end property;

property wait_5 is
  dependencies: no_reset;
  for timepoints:
    t_end = t+1;
  freeze:
    atT_value_output = value_output @ t,
    atT_value_old = value_old @ t,
    atT_value_output_sig_o = value_output_sig_o @ t;
  assume:
    at t: output_W_2;
    at t: (not value_output_sync);
  prove:
    at t+1: sensor_notify = false;
    at t+1: value_output_notify = true;
	
    at t+1: value_output = atT_value_output;
    at t+1: value_output_sig_o = atT_value_output_sig_o; --needs to be adde d
    at t+1: value_old = atT_value_old;
    at t+1: output_W_2;
end property;

--Process finished with exit code 0
